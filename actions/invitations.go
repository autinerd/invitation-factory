package actions

import (
	"log"
	"strconv"
	"strings"

	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop"
	"github.com/gobuffalo/uuid"
	"github.com/invitation/models"
	"github.com/pkg/errors"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Invitation)
// DB Table: Plural (invitations)
// Resource: Plural (Invitations)
// Path: Plural (/invitations)
// View Template Folder: Plural (/templates/invitations/)

// InvitationsResource is the resource for the Invitation model
type InvitationsResource struct {
	buffalo.Resource
}

// List gets all Invitations and list them.
// This function is mapped to the path GET /invitations
func (v InvitationsResource) List(c buffalo.Context) error {
	u := c.Value("current_user").(*models.User)
	c.Set("invitations", u.Invitations)
	return c.Render(200, r.Auto(c, u.Invitations))
}

// Show gets the data for one Invitation. This function is mapped to
// the path GET /invitations/{invitation_id}
func (v InvitationsResource) Show(c buffalo.Context) error {
	u := c.Value("current_user").(*models.User)
	invitation := getInvitationFromID(u, uuid.FromStringOrNil(c.Param("invitation_id")))
	if invitation == nil {
		return c.Error(404, errors.New("This invitation ID does not exist"))
	}

	c.Set("guests", invitation.Guests)
	return c.Render(200, r.Auto(c, invitation))
}

// New renders the form for creating a new Invitation.
// This function is mapped to the path GET /invitations/new
func (v InvitationsResource) New(c buffalo.Context) error {
	return c.Render(200, r.Auto(c, &models.Invitation{}))
}

// Create adds a Invitation to the DB. This function is mapped to the
// path POST /invitations
func (v InvitationsResource) Create(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		log.Println("Error while getting data from the database")
		return c.Error(500, errors.New("Internal Server Error"))
	}
	u := c.Value("current_user").(*models.User)

	c.Request().ParseForm()
	inv, err := formParser(c.Request().Form)
	if err != nil {
		c.Flash().Add("danger", err.Error())
		return c.Render(422, r.Auto(c, inv))
	}

	inv.UserID = u.ID
	verrs, err := tx.Eager().ValidateAndCreate(inv)

	if err != nil {
		log.Println(err.Error())
		c.Flash().Add("danger", "Error while creating the invitation")
		return c.Render(422, r.Auto(c, inv))
	}

	if verrs.HasAny() {
		for _, values := range verrs.Errors {
			for _, value := range values {
				c.Flash().Add("danger", value)
			}
		}
		c.Set("errors", verrs)
		return c.Render(422, r.Auto(c, inv))
	}
	c.Flash().Add("success", "Invitation was created successfully")
	return c.Render(201, r.Auto(c, inv))
}

// Edit renders a edit form for a Invitation. This function is
// mapped to the path GET /invitations/{invitation_id}/edit
func (v InvitationsResource) Edit(c buffalo.Context) error {
	u := c.Value("current_user").(*models.User)

	invitation := getInvitationFromID(u, uuid.FromStringOrNil(c.Param("invitation_id")))
	if invitation == nil {
		return c.Error(404, errors.New("This invitation ID does not exist"))
	}
	c.Set("guests", invitation.Guests)
	return c.Render(200, r.Auto(c, invitation))
}

// Update changes a Invitation in the DB. This function is mapped to
// the path PUT /invitations/{invitation_id}
func (v InvitationsResource) Update(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		log.Println("Error while getting data from the database")
		return c.Error(500, errors.New("Internal Server Error"))
	}

	u := c.Value("current_user").(*models.User)

	invitation := getInvitationFromID(u, uuid.FromStringOrNil(c.Param("invitation_id")))
	if invitation == nil {
		return c.Error(404, errors.New("This invitation ID does not exist"))
	}
	if invitation.SentToGuests == true {
		return c.Error(403, errors.New("After sending the invitation editing is not allowed anymore"))
	}

	invID := invitation.ID

	if err := tx.Destroy(&invitation.Guests); err != nil {
		log.Println("Error while getting data from the database")
		return c.Error(500, errors.New("Internal Server Error"))
	}

	if err := tx.Destroy(invitation); err != nil {
		log.Println("Error while getting data from the database")
		return c.Error(500, errors.New("Internal Server Error"))
	}

	c.Request().ParseForm()
	inv, err := formParser(c.Request().Form)

	if err != nil {
		c.Flash().Add("danger", err.Error())
		return c.Render(422, r.Auto(c, inv))
	}

	inv.UserID = u.ID
	inv.ID = invID
	verrs, err := tx.Eager().ValidateAndCreate(inv)

	if err != nil {
		log.Println(err.Error())
		c.Flash().Add("danger", "Error while creating the invitation")
		return c.Render(422, r.Auto(c, inv))
	}

	if verrs.HasAny() {
		for _, values := range verrs.Errors {
			for _, value := range values {
				c.Flash().Add("danger", value)
			}
		}

		c.Set("errors", verrs)
		return c.Render(422, r.Auto(c, inv))
	}

	c.Flash().Add("success", "Invitation was updated successfully")
	return c.Render(201, r.Auto(c, inv))
}

// Destroy deletes a Invitation from the DB. This function is mapped
// to the path DELETE /invitations/{invitation_id}
func (v InvitationsResource) Destroy(c buffalo.Context) error {
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		log.Println("Error while getting data from the database")
		return c.Error(500, errors.New("Internal Server Error"))
	}

	u := c.Value("current_user").(*models.User)

	invitation := getInvitationFromID(u, uuid.FromStringOrNil(c.Param("invitation_id")))

	if invitation == nil {
		return c.Error(404, errors.New("This invitation ID does not exist"))
	}

	if err := tx.Destroy(&invitation.Guests); err != nil {
		log.Println("Error while getting data from the database")
		return c.Error(500, errors.New("Internal Server Error"))
	}

	if err := tx.Destroy(invitation); err != nil {
		log.Println("Error while getting data from the database")
		return c.Error(500, errors.New("Internal Server Error"))
	}

	c.Flash().Add("success", "Invitation was deleted successfully")
	return c.Render(200, r.Auto(c, invitation))
}

// formParser parses the invitation form and the guests and returns the parsed invitation.
func formParser(m map[string][]string) (*models.Invitation, error) {
	invitation := &models.Invitation{}
	length := getLastIndexOfGuests(m)

	if length >= 100 {
		return &models.Invitation{}, errors.New("Too much guests or last index too high")
	}

	invitation.Guests = make(models.Guests, length+1)
	for i := 0; i < cap(invitation.Guests); i++ {
		invitation.Guests[i] = models.Guest{}
	}

	for key, values := range m {
		lowerkey := strings.ToLower(key)
		switch {
		case lowerkey == "mailtext":
			if values[0] == "" {
				return &models.Invitation{}, errors.New("Please fill in a body text")
			}
			invitation.Mailtext = values[0]
		case lowerkey == "salutation":
			invitation.Salutation, _ = strconv.Atoi(values[0])
		case strings.Contains(lowerkey, "name"):
			i, _ := strconv.Atoi(lowerkey[4:])
			invitation.Guests[i].Name = values[0]
		case strings.Contains(lowerkey, "mail"):
			i, _ := strconv.Atoi(lowerkey[4:])
			invitation.Guests[i].Email = values[0]
		case strings.Contains(lowerkey, "gender"):
			i, _ := strconv.Atoi(lowerkey[6:])
			i2, _ := strconv.Atoi(values[0])
			invitation.Guests[i].Gender = i2
		}
	}

	guests2 := models.Guests{}
	for _, guest := range invitation.Guests {
		if guest.Email != "" {
			guests2 = append(guests2, guest)
		}
	}

	invitation.Guests = guests2
	return invitation, nil
}

func getLastIndexOfGuests(m map[string][]string) int {
	length := 0
	for key := range m {
		lowerkey := strings.ToLower(key)
		if strings.Contains(lowerkey, "gender") {
			l, _ := strconv.Atoi(lowerkey[6:])
			if l > length {
				length = l
			}
		}
	}
	return length
}

// getInvitationFromID returns an invitation from the given user with the given ID, nil when the user doesn't have an invitation with that ID
func getInvitationFromID(u *models.User, id uuid.UUID) *models.Invitation {
	for _, invitation := range u.Invitations {
		if invitation.ID == id {
			return &invitation
		}
	}
	return nil
}
